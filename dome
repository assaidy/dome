#!/usr/bin/env python3

import curses
import json
import os
from typing import List

FILE_PATH = f"{os.path.expanduser('~')}/.local/share/dome/tasks.json"


class Task:
    def __init__(self, name: str, completed: bool = False) -> None:
        self.name = name
        self.completed = completed

    def __repr__(self) -> str:
        status = 'x' if self.completed else ' '
        return f"- [{status}] {self.name}"

    def toggle_completed(self):
        self.completed = not self.completed


def display_bar(window, y: int, width: int, text: str):
    centered_text = text.center(width)
    window.addstr(y, 0, "-" * width)
    window.addstr(y + 1, 0, centered_text, curses.A_BOLD)
    window.addstr(y + 2, 0, "-" * width)


def load_tasks() -> List[Task]:
   if os.path.exists(FILE_PATH) and os.path.getsize(FILE_PATH) > 0:
       with open(FILE_PATH, 'r') as file:
           return [Task(**task) for task in json.load(file)]
   else:
       with open(FILE_PATH, 'w') as file:
           json.dump([], file)
       return []



def save_tasks(tasks: List[Task]):
    with open(FILE_PATH, 'w') as file:
        json.dump([task.__dict__ for task in tasks], file, indent=4)


def prompt_for_task_name(window, prompt: str, width: int, height: int) -> str:
    separator_y = height - 2  # One line above the last line for the separator
    prompt_y = height - 1  # Last line for the prompt

    # Draw the separator bar
    window.addstr(separator_y, 0, "-" * width)

    # Move cursor to the last line and show the prompt
    window.move(prompt_y, 0)
    window.clrtoeol()  # Clear the line
    window.addstr(prompt_y, 0, prompt)
    curses.curs_set(1)  # Make cursor visible
    curses.echo()

    # Capture input with the ability to cancel with the Escape key
    task_name = []
    while True:
        ch = window.getch()
        if ch == 27:  # Escape key
            curses.noecho()
            curses.curs_set(0)
            return None
        elif ch in (curses.KEY_ENTER, 10, 13):  # Enter key
            break
        else:
            task_name.append(chr(ch))
            window.addch(ch)

    curses.noecho()
    curses.curs_set(0)  # Hide cursor again
    return ''.join(task_name).strip()


def main(stdscr):
    tasks = load_tasks()
    todos = [task for task in tasks if not task.completed]
    dones = [task for task in tasks if task.completed]

    curses.curs_set(0)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)

    height, width = stdscr.getmaxyx()
    window = curses.newwin(height, width, 0, 0)

    selected_idx = 0
    tab = "todo"

    while True:
        window.clear()
        display_bar(window, 0, width,
                    "[Todo] Done" if tab == "todo" else "Todo [Done]")

        task_list = todos if tab == "todo" else dones
        for i, task in enumerate(task_list):
            text_format = curses.color_pair(
                1) if selected_idx == i else curses.A_NORMAL
            window.addstr(4 + i, 0, task.__repr__(), text_format)

        ch = window.getch()
        if ch == ord('j') and task_list:
            selected_idx = (selected_idx + 1) % len(task_list)
        elif ch == ord('k') and task_list:
            selected_idx = (selected_idx - 1) % len(task_list)
        elif ch == ord('\t'):
            tab = "done" if tab == "todo" else "todo"
            selected_idx = 0
        elif ch == ord('\n') and task_list:
            task_list[selected_idx].toggle_completed()
            selected_idx = max(0, selected_idx - 1)
            tasks = todos + dones
            save_tasks(tasks)
        elif ch == ord('a') and tab == "todo":
            task_name = prompt_for_task_name(
                window, "Enter task name: ", width, height)
            if task_name is not None:  # Check if the task name is not empty and not cancelled
                tasks.append(Task(task_name))
                save_tasks(tasks)
        elif ch == ord('r') and task_list:
            task_name = prompt_for_task_name(
                window, "Enter new task name: ", width, height)
            if task_name is not None:  # Check if the task name is not empty and not cancelled
                task_list[selected_idx].name = task_name
                save_tasks(tasks)
        elif ch == ord('q'):
            break

        todos = [task for task in tasks if not task.completed]
        dones = [task for task in tasks if task.completed]


if __name__ == "__main__":
    curses.wrapper(main)
